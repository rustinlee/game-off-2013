<html>
	<head>
		<title>Armipotent HTML5 Alpha</title>
		<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
		<script src="js/jquery.hotkeys.js"></script>
		<style>body{background-color:navy;}</style>
	</head>
	<body>
		<div id="canvas"></div>
		<script type="text/javascript">
			var CANVAS_WIDTH 	= 640;
			var CANVAS_HEIGHT 	= 480;

			var canvasElement = $("<canvas width='" + CANVAS_WIDTH + "' height='" + CANVAS_HEIGHT + "'></canvas>");
			var canvas = canvasElement.get(0).getContext("2d");
			canvasElement.appendTo('#canvas');

			function findPos(obj) {
			    var curleft = 0, curtop = 0;
			    if (obj.offsetParent) {
			        do {
			            curleft += obj.offsetLeft;
			            curtop += obj.offsetTop;
			        } while (obj = obj.offsetParent);
			        return { x: curleft, y: curtop };
			    }
			    return undefined;
			}

			var currentMousePos = { x: -1, y: -1 };
			$('#canvas').mousemove(function(e) {
			    var pos = findPos(this);
			    currentMousePos.x = e.pageX - pos.x;
			    currentMousePos.y = e.pageY - pos.y;
			});

			var mouseDown = false;
			$(document).mousedown(function() {
			    mouseDown = true;
			}).mouseup(function() {
			    mouseDown = false;  
			});

			$(function() {
			  window.keydown = {};
			  
			  function keyName(event) {
			    return jQuery.hotkeys.specialKeys[event.which] ||
			      String.fromCharCode(event.which).toLowerCase();
			  }
			  
			  $(document).bind("keydown", function(event) {
			    keydown[keyName(event)] = true;
			  });
			  
			  $(document).bind("keyup", function(event) {
			    keydown[keyName(event)] = false;
			  });
			});

			setInterval(function() {
				step();
				draw();
			}, 1000/60);

			var gravity = 2;
			var friction = 1;
			
			function entity() {
			}

			entity.prototype = {
				draw: function() {
					canvas.fillStyle = this.color;
					canvas.fillRect(this.x - camera.x, this.y - camera.y, this.width, this.height);
				}
			}

			function creature(x, y, width, height, color, maxHP) {
				this.x = x;
				this.y = y;
				this.xv = 0;
				this.yv = 0;
				this.width = width; //sprites will define these
				this.height = height; //
				this.color = color; //
				this.maxHP = maxHP;
				this.HP = this.maxHP;
				this.runSpeed = 6;
				this.isJumping = false;
				this.jumpHeight = 25;
				this.firePower = 1;
				this.alive = true;
				this.collided = false;
				this.collisionNormal = [0.0,0.0];
				this.step = function() {
					this.collided = false; //innocent until proven guilty

					this.yv+=gravity;

					if(this.yv > gravity && this.collided && this.collisionNormal[1] == -1) {
						this.yv = gravity;
					}

					var broadphasebox = getSweptBroadphaseBox(this);
					for (var i = walls.length - 1; i >= 0; i--) {
						if (checkAABB(broadphasebox,walls[i])) {
							var collisiontime = sweptAABB(this, walls[i]);
							var remainingtime = 1.0 - collisiontime;
							if(remainingtime != 0) { //if there was a collision
								this.x += this.xv * collisiontime;
								this.y += this.yv * collisiontime;
								var dotprod = (this.xv * this.collisionNormal[1] + this.yv * this.collisionNormal[0]) * remainingtime;
								this.xv = dotprod * this.collisionNormal[1];
								this.yv = dotprod * this.collisionNormal[0];
								this.collided = true;
							}
						}
					};

					this.x += this.xv;
					this.y += this.yv;

					if (this.xv>0) {
						this.xv-=friction;
						if (this.xv<0) {
							this.xv = 0;
						}
					} else if (this.xv<0) {
						this.xv+=friction;
						if (this.xv>0) {
							this.xv = 0;
						}
					}
				};
				this.setNormal = function(x, y) {
					this.collisionNormal[0] = x;
					this.collisionNormal[1] = y;
				};
				this.jump = function() { //better handling all around needed
					if(this.collided && this.collisionNormal[1] == -1){
						this.yv -= this.jumpHeight;
					}
				};
			}

			creature.prototype = new entity();

			creatures = new Array();

			creatures[0] = new creature(460, 30, 64, 64, "#FF5A00", 15);

			player = new creature(220, 270, 32, 32, "#00A", 100);			

			player.fire = function() {
				var radx = currentMousePos.x - (this.x+this.width/2);
				var rady = (currentMousePos.y - (this.y+this.height/2))*-1;
				var angle = Math.atan(rady/radx)/(Math.PI/180);
			    if (radx <0) {
			        angle += 180;
			    }
			    angle = angle*-1;			
				projectiles.push(new projectile(this.x + this.width/2, this.y + this.height/2, Math.cos(angle*Math.PI/180)*this.firePower, Math.sin(angle*Math.PI/180)*this.firePower));
			};

			function projectile(x, y, xv, yv) {
				this.x = x;
				this.y = y;
				this.xv = xv;
				this.yv = yv;
				this.width = 2;
				this.height = 2;
				this.color = "#00A";
				this.ttl = 300;
				this.alive = true;
				this.step = function() {
					this.x += this.xv;
					this.y += this.yv;
					this.ttl -= 1;
					if(this.ttl <= 0) {
						this.alive = false;
					}
				};
			}

			projectile.prototype = new entity();

			var projectiles = new Array();

			var camera = {
				x: 0,
				y: 0,
			}

			function handleKeys() {
				// player controls
				if (keydown.a) {
					player.xv -= 2;
					if(player.xv<-(player.runSpeed)){
						player.xv = -(player.runSpeed);
					}
				}

				if (keydown.d) {
					player.xv += 2;
					if(player.xv>player.runSpeed){
						player.xv = player.runSpeed;
					}
				}

				if (keydown.space && !player.isJumping) { //need to figure out how to bind keypress
					player.jump();
					player.isJumping = true;
				}

				if (!keydown.space) {
					player.isJumping = false;
				}

				// camera controls (debug)
				if (keydown.up) {
					camera.y -= 5;
				}

				if (keydown.down) {
					camera.y += 5;
				}

				if (keydown.left) {
					camera.x -= 5;
				}

				if (keydown.right) {
					camera.x += 5;
				}												
			}

			function handleMouse() {
				if (mouseDown) {
					player.fire();
				}
			}

			function wall(width, height, x, y, color, collision) {
				this.width = width;
				this.height = height;
				this.x = x;
				this.y = y;
				this.color = color;
				this.collision = collision;
			}

			wall.prototype = new entity();

			var walls = new Array();

			function initLevel() {
				$.get("data/level1.csv", function(data){ //only actually covers walls atm
					var levelData = data;
					var lines = levelData.split("\n");

					for (var i = lines.length - 1; i >= 0; i--) {
						var a = lines[i].split(",");

						a[0] = parseInt(a[0]);
						a[1] = parseInt(a[1]);
						a[2] = parseInt(a[2]);
						a[3] = parseInt(a[3]);
						a[5] = parseInt(a[5]);
						walls[i] = new wall(a[0], a[1], a[2], a[3], a[4], a[5]);
					};
				});
			}

			initLevel();

			function sweptAABB(b1, b2) {
			    var xInvEntry, yInvEntry;
			    var xInvExit, yInvExit;

			    if (b1.xv > 0.0)
			    {
			        xInvEntry = b2.x - (b1.x + b1.width);
			        xInvExit = (b2.x + b2.width) - b1.x;
			    }
			    else 
			    {
			        xInvEntry = (b2.x + b2.width) - b1.x;
			        xInvExit = b2.x - (b1.x + b1.width);
			    }

			    if (b1.yv > 0.0)
			    {
			        yInvEntry = b2.y - (b1.y + b1.height);
			        yInvExit = (b2.y + b2.height) - b1.y;
			    }
			    else
			    {
			        yInvEntry = (b2.y + b2.height) - b1.y;
			        yInvExit = b2.y - (b1.y + b1.height);
			    }

			    var xEntry, yEntry;
			    var xExit, yExit;

			    if (b1.xv == 0.0)
			    {
			        xEntry = Number.NEGATIVE_INFINITY;
			        xExit = Number.POSITIVE_INFINITY;
			    }
			    else
			    {
			        xEntry = xInvEntry / b1.xv;
			        xExit = xInvExit / b1.xv;
			    }

			    if (b1.yv == 0.0)
			    {
			        yEntry = Number.NEGATIVE_INFINITY;
			        yExit = Number.POSITIVE_INFINITY;
			    }
			    else
			    {
			        yEntry = yInvEntry / b1.yv;
			        yExit = yInvExit / b1.yv;
			    }

				var entryTime = Math.max(xEntry, yEntry);
				var exitTime = Math.min(xExit, yExit);

				var normalx;
				var normaly;

				if (entryTime > exitTime || xEntry < 0.0 && yEntry < 0.0 || xEntry > 1.0 || yEntry > 1.0)
				{
					normalx = 0.0;
					normaly = 0.0;
					b1.setNormal(normalx, normaly);
					return 1.0;
				}

				else // if there was a collision
			    {        		
			        // calculate normal of collided surface
			        if (xEntry > yEntry)
			        {
			            if (xInvEntry < 0.0)
			            {
			                normalx = 1.0;
			                normaly = 0.0;
			                b1.setNormal(normalx, normaly);
			            }
				        else
			            {
			                normalx = -1.0;
			                normaly = 0.0;
			                b1.setNormal(normalx, normaly);
			            }
			        }
			        else
			        {
			            if (yInvEntry < 0.0)
			            {
			                normalx = 0.0;
			                normaly = 1.0;
			                b1.setNormal(normalx, normaly);
			            }
				        else
			            {
			                normalx = 0.0;
					        normaly = -1.0;
					        b1.setNormal(normalx, normaly);
			            }
			        }

			        // return the time of collision
			        return entryTime;
			    }
			}

			function box(x, y, width, height, xv, yv){
				var x, y;
				var width, height;
				var xv, yv;
			}

			function getSweptBroadphaseBox(b){
				var broadphasebox = new box();
				broadphasebox.x = b.xv > 0 ? b.x : b.x + b.xv;
				broadphasebox.y = b.yv > 0 ? b.y : b.y + b.yv;
				broadphasebox.width = b.xv > 0 ? b.xv + b.width : b.width - b.xv;
				broadphasebox.height = b.yv > 0 ? b.yv + b.height : b.height - b.yv;

				return broadphasebox;
			}

			function checkAABB (b1, b2){
				return !(b1.x + b1.width < b2.x || b1.x > b2.x + b2.width || b1.y + b1.height < b2.y || b1.y > b2.y + b2.height);
			}

			function step() {
				handleKeys();
				handleMouse();

				player.step();

				for (var i = projectiles.length - 1; i >= 0; i--) {
					projectiles[i].step();
				};

				projectiles = projectiles.filter(function(projectile) {
					return projectile.alive;
				});

				for (var i = creatures.length - 1; i >= 0; i--) {
					creatures[i].step();
				};
			}

			function draw() { //need to write a camera function
				canvas.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
				canvas.fillStyle="#FFFFFF";
				canvas.fillRect(0,0,640,480);
				player.draw();
				for (var i = walls.length - 1; i >= 0; i--) {
					walls[i].draw();
				};
				for (var i = projectiles.length - 1; i >= 0; i--) {
					projectiles[i].draw();
				};
				for (var i = creatures.length - 1; i >= 0; i--) {
					creatures[i].draw();
				};
			}
		</script>
	</body>
</html>